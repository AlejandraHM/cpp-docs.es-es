---
title: Error del compilador C2910 | Documentos de Microsoft
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- C2910
dev_langs:
- C++
helpviewer_keywords:
- C2910
ms.assetid: 09c50e6a-e099-42f6-8ed6-d80e292a7a36
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 202593b506fc957fb98cc390c1874312509ea481
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/21/2017
---
# <a name="compiler-error-c2910"></a>Error del compilador C2910
'función': no se puede especializar de forma explícita  
  
 El compilador detectó un intento de especializar de forma explícita una función dos veces.  
  
 El ejemplo siguiente genera el error C2910:  
  
```  
// C2910.cpp  
// compile with: /c  
template <class T>  
struct S;  
  
template <> struct S<int> { void f() {} };  
template <> void S<int>::f() {}   // C2910 delete this specialization  
```  
  
 También puede generarse el error C2910 si se intenta especializar explícitamente un miembro no es de plantilla. Es decir, solo explícitamente pueden especializar una plantilla de función.  
  
 El ejemplo siguiente genera el error C2910:  
  
```  
// C2910b.cpp  
// compile with: /c  
template <class T> struct A {  
   A(T* p);  
};  
  
template <> struct A<void> {  
   A(void* p);  
};  
  
template <class T>  
inline A<T>::A(T* p) {}  
  
template <> A<void>::A(void* p){}   // C2910  
// try the following line instead  
// A<void>::A(void* p){}  
```  
  
 Este error también se generará como resultado del trabajo de conformidad del compilador efectuado en Visual Studio .NET 2003:.  
  
 Para obtener código será válido en las versiones de Visual Studio .NET 2003 y Visual Studio .NET de Visual C++, quite `template <>`.  
  
 El ejemplo siguiente genera el error C2910:  
  
```  
// C2910c.cpp  
// compile with: /c  
template <class T> class A {  
   void f();  
};  
  
template <> class A<int> {  
   void f();  
};  
  
template <> void A<int>::f() {}   // C2910  
// try the following line instead  
// void A<int>::f(){}   // OK  
```